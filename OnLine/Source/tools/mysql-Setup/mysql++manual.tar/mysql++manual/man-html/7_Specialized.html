<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">

<!--Converted with LaTeX2HTML 99.2beta8 (1.43)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>7. Specialized SQL Structures</TITLE>
<META NAME="description" CONTENT="7. Specialized SQL Structures">
<META NAME="keywords" CONTENT="manual">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<META NAME="Generator" CONTENT="LaTeX2HTML v99.2beta8">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="manual.css">

<LINK REL="next" HREF="8_Long.html">
<LINK REL="previous" HREF="6_Template.html">
<LINK REL="up" HREF="Usage.html">
<LINK REL="next" HREF="8_Long.html">
</HEAD>

<BODY >
<!--Navigation Panel-->
<A NAME="tex2html389"
  HREF="8_Long.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html385"
  HREF="Usage.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html379"
  HREF="6_Template.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html387"
  HREF="Contents.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A>  
<BR>
<B> Next:</B> <A NAME="tex2html390"
  HREF="8_Long.html">8. Long Names</A>
<B> Up:</B> <A NAME="tex2html386"
  HREF="Usage.html">Usage</A>
<B> Previous:</B> <A NAME="tex2html380"
  HREF="6_Template.html">6. Template Queries</A>
 &nbsp <B>  <A NAME="tex2html388"
  HREF="Contents.html">Contents</A></B> 
<BR>
<BR>
<!--End of Navigation Panel-->
<!--Table of Child-Links-->
<A NAME="CHILD_LINKS"><STRONG>Subsections</STRONG></A>

<UL>
<LI><A NAME="tex2html391"
  HREF="7_Specialized.html#SECTION03410000000000000000">7.1 sql_create_basic </A>
<LI><A NAME="tex2html392"
  HREF="7_Specialized.html#SECTION03420000000000000000">7.2 sql_create_basic with compare </A>
<LI><A NAME="tex2html393"
  HREF="7_Specialized.html#SECTION03430000000000000000">7.3 sql_create_basic with Additional Constructor </A>
<LI><A NAME="tex2html394"
  HREF="7_Specialized.html#SECTION03440000000000000000">7.4 sql_create_basic General Format </A>
<LI><A NAME="tex2html395"
  HREF="7_Specialized.html#SECTION03450000000000000000">7.5 sql_create_basic_c_order </A>
<LI><A NAME="tex2html396"
  HREF="7_Specialized.html#SECTION03460000000000000000">7.6 sql_create_basic_c_order General Format </A>
<LI><A NAME="tex2html397"
  HREF="7_Specialized.html#SECTION03470000000000000000">7.7 sql_create </A>
<LI><A NAME="tex2html398"
  HREF="7_Specialized.html#SECTION03480000000000000000">7.8 sql_create_c_names </A>
<LI><A NAME="tex2html399"
  HREF="7_Specialized.html#SECTION03490000000000000000">7.9 sql_create_c_names General Format </A>
<LI><A NAME="tex2html400"
  HREF="7_Specialized.html#SECTION034100000000000000000">7.10 sql_create_c_order </A>
<LI><A NAME="tex2html401"
  HREF="7_Specialized.html#SECTION034110000000000000000">7.11 sql_create_complete </A>
<LI><A NAME="tex2html402"
  HREF="7_Specialized.html#SECTION034120000000000000000">7.12 Changing the table name </A>
<LI><A NAME="tex2html403"
  HREF="7_Specialized.html#SECTION034130000000000000000">7.13 Seeing the actual code </A>
<LI><A NAME="tex2html404"
  HREF="7_Specialized.html#SECTION034140000000000000000">7.14 Adding functionality </A>
<LI><A NAME="tex2html405"
  HREF="7_Specialized.html#SECTION034150000000000000000">7.15 Other notes </A>
</UL>
<!--End of Table of Child-Links-->
<HR>

<H1><A NAME="SECTION03400000000000000000"></A><A NAME="SSQLS"></A>
<BR>
7. Specialized SQL Structures
</H1>

<P>
The Specialized SQL Structures (SSQLS) allows you create structures
to hold data for mysql queries with extra functionality to make your
life easier. These structures are in no way related to any Standard
Template Library (STL) type of containers. These structures are exactly
that <B>structs</B>.  Each member item is stored  with a unique
name within the structure.  You can in no way use STL algorithms are
anything else STL to work with the individual structures. However
you CAN use these structures as the <B>value_type</B> for STL containers.
(They would be pretty useless if you couldn't.) 

<P>

<H1><A NAME="SECTION03410000000000000000">
7.1 sql_create_basic </A>
</H1>

<P>
The following command will create a basic mysql query for use with
the  sample database. 

<P>

<DL COMPACT>
<DT>
<DD><TT>sql_create_basic_5(stock,&nbsp;0,&nbsp;0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;string,&nbsp;item,&nbsp;//&nbsp;type,&nbsp;id,&nbsp;&nbsp;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int,&nbsp;num,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double,&nbsp;weight,&nbsp;&nbsp;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double,&nbsp;price,&nbsp;&nbsp;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MysqlDate,&nbsp;date)&nbsp;</TT>
</DD>
</DL> This will set up the following structure: 

<P>

<DL COMPACT>
<DT>
<DD><TT>struct&nbsp;stock&nbsp;{&nbsp;&nbsp;&nbsp;
<BR>&nbsp;&nbsp;stock&nbsp;()&nbsp;{}&nbsp;&nbsp;
<BR>&nbsp;&nbsp;stock&nbsp;(const&nbsp;MysqlRow&nbsp;&amp;row);&nbsp;
<BR>&nbsp;&nbsp;set&nbsp;(const&nbsp;MysqlRow&nbsp;&amp;row);&nbsp;
<BR>&nbsp;&nbsp;&nbsp;
<BR>&nbsp;&nbsp;string&nbsp;item;&nbsp;&nbsp;
<BR>&nbsp;&nbsp;int&nbsp;num;&nbsp;&nbsp;
<BR>&nbsp;&nbsp;double&nbsp;weight;&nbsp;&nbsp;
<BR>&nbsp;&nbsp;double&nbsp;price;&nbsp;&nbsp;
<BR>&nbsp;&nbsp;MysqlDate&nbsp;date;&nbsp;&nbsp;
<BR>};&nbsp;</TT>
</DD>
</DL> As you can see this is nothing fancy.  The main advantage of this
simple structure is the <B>stock (MysqlRow &amp;row)</B> constructor
which allows you to easily populate a vector of stocks like so: 

<P>

<DL COMPACT>
<DT>
<DD><TT>vector&lt;stock&gt;&nbsp;result;&nbsp;&nbsp;&nbsp;
<BR>
query.storein(result);&nbsp;</TT>
</DD>
</DL> That's all there is two it. The requirements are that the query returns
elements in the same order as you specified them in the custom structure. 

<P>
The general format is: 

<P>

<DL COMPACT>
<DT>
<DD><TT>sql_create_basic_#(NAME,&nbsp;0,&nbsp;0,&nbsp;TYPE1,&nbsp;ITEM1,&nbsp;...&nbsp;TYPE#,&nbsp;ITEM#)&nbsp;&nbsp;</TT>
</DD>
</DL> Where # is the number of valuables in the vector, NAME is the name
of the structure you wish to create, and TYPE1 is the type name for
first item and ITEM1 is the valuables name for the first item etc.. 

<P>

<H1><A NAME="SECTION03420000000000000000">
7.2 sql_create_basic with compare </A>
</H1>

<P>
You can also make the structure comparable by changing the first 0
in the previous example to a non zero number.  This number, lets call
it n, will tell c++ that if the first n number or the same then the
two structures are the same. 

<P>
For example: 

<P>

<DL COMPACT>
<DT>
<DD><TT>sql_create_basic_5(stock,&nbsp;1,&nbsp;0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;string,&nbsp;item,&nbsp;//&nbsp;type,&nbsp;id,&nbsp;&nbsp;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int,&nbsp;num,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double,&nbsp;weight,&nbsp;&nbsp;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double,&nbsp;price,&nbsp;&nbsp;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MysqlDate,&nbsp;date)&nbsp;</TT>
</DD>
</DL> will create a structure where only the item valuable is checked to
see if two different stocks are the same.  It also allows you to compare
one structure to another based on the value of item. (If n is greater
than one it will compare the structures in a Lexicographic order.
 For example if it was 2 it would first compare <TT>item</TT> and
if item was the same it would  then compare <TT>num</TT>.  If num
was the same it would declare the two structures the same.) 

<P>
In addition what the previous example defines it also defines the
following: 

<P>

<DL COMPACT>
<DT>
<DD><TT>struct&nbsp;stock&nbsp;&nbsp;&nbsp;&nbsp;
<BR>&nbsp;&nbsp;...&nbsp;&nbsp;
<BR>&nbsp;&nbsp;stock&nbsp;(const&nbsp;string&nbsp;&amp;p1);&nbsp;
<BR>&nbsp;&nbsp;set&nbsp;(const&nbsp;string&nbsp;&amp;p1);&nbsp;
<BR>&nbsp;&nbsp;bool&nbsp;operator&nbsp;==&nbsp;(const&nbsp;stock&nbsp;&amp;other)&nbsp;const;&nbsp;&nbsp;
<BR>&nbsp;&nbsp;bool&nbsp;operator&nbsp;!=&nbsp;(const&nbsp;stock&nbsp;&amp;other)&nbsp;const;&nbsp;&nbsp;&nbsp;
<BR>&nbsp;&nbsp;bool&nbsp;operator&nbsp;&gt;&nbsp;(const&nbsp;stock&nbsp;&amp;other)&nbsp;const;&nbsp;&nbsp;&nbsp;
<BR>&nbsp;&nbsp;bool&nbsp;operator&nbsp;&lt;&nbsp;(const&nbsp;stock&nbsp;&amp;other)&nbsp;const;&nbsp;&nbsp;&nbsp;
<BR>&nbsp;&nbsp;bool&nbsp;operator&nbsp;&gt;=&nbsp;(const&nbsp;stock&nbsp;&amp;other)&nbsp;const;&nbsp;&nbsp;&nbsp;
<BR>&nbsp;&nbsp;bool&nbsp;operator&nbsp;&lt;=&nbsp;(const&nbsp;stock&nbsp;&amp;other)&nbsp;const;&nbsp;&nbsp;&nbsp;
<BR>&nbsp;&nbsp;int&nbsp;cmp&nbsp;(const&nbsp;stock&nbsp;&amp;other)&nbsp;const;&nbsp;&nbsp;
<BR>&nbsp;&nbsp;int&nbsp;compare&nbsp;(const&nbsp;stock&nbsp;&amp;other)&nbsp;const;&nbsp;&nbsp;
<BR>}&nbsp;&nbsp;
<BR>&nbsp;&nbsp;
<BR>
int&nbsp;compare&nbsp;(const&nbsp;stock&nbsp;&amp;x,&nbsp;const&nbsp;stock&nbsp;&amp;y);&nbsp;</TT>
</DD>
</DL> int compare (const stock &amp;x, const stock &amp;y) compares x to y and
return &lt;0 if  x &lt; y, 0 if x = y, and &gt;0 if x &gt; y.  stock::cmp and
stock::compare are the same thing as compare(*this, other). 

<P>
stock::stock is a constructor that will set item to p1 and leave the
other variables undefined.  This is useful for creating temporary
objects to use for comparisons like x &lt;= stock(&#34;Hotdog&#34;).

<P>
Because <B>stock</B> is now less-then-comparable you can store the
query results in a set: 

<P>

<DL COMPACT>
<DT>
<DD><TT>set&lt;stock&gt;&nbsp;result;&nbsp;&nbsp;&nbsp;
<BR>
query.storein(result);&nbsp;</TT>
</DD>
</DL> And you can now use it like any other set, for example: 

<P>

<DL COMPACT>
<DT>
<DD><TT>cout&nbsp;&lt;&lt;&nbsp;result.lower_bound(stock(&#34;Hamburger&#34;))-&gt;item&nbsp;&lt;&lt;&nbsp;endl;&nbsp;&nbsp;</TT>
</DD>
</DL> will return the first item that begins with Hamburger. 

<P>
You can also now use it will any STL algorithm that require the values
to be less-then-comparable. 

<P>
The general format so far is: 

<P>

<DL COMPACT>
<DT>
<DD><TT>sql_create_base_#(NAME,&nbsp;CMP,&nbsp;0,&nbsp;TYPE1,&nbsp;ITEM1,&nbsp;...&nbsp;TYPE#,&nbsp;ITEM#)&nbsp;&nbsp;</TT>
</DD>
</DL> where CMP is that the number that tells c++ that if the first cmp
variables are the same then the two structures are the same. 

<P>

<H1><A NAME="SECTION03430000000000000000">
7.3 sql_create_basic with Additional Constructor </A>
</H1>

<P>
The last zero in the last example if for creating another constructor.
Let this zero be m then it will create a constructor which will populate
the first n variables.  For example: 

<P>

<DL COMPACT>
<DT>
<DD><TT>sql_create_basic_5(stock,&nbsp;1,&nbsp;5,&nbsp;&nbsp;&nbsp;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;string,&nbsp;item,&nbsp;//&nbsp;type,&nbsp;id,&nbsp;&nbsp;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int,&nbsp;num,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double,&nbsp;weight,&nbsp;&nbsp;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double,&nbsp;price,&nbsp;&nbsp;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MysqlDate,&nbsp;date)&nbsp;</TT>
</DD>
</DL> will also define: 

<P>

<DL COMPACT>
<DT>
<DD><TT>struct&nbsp;stock&nbsp;{&nbsp;&nbsp;&nbsp;
<BR>&nbsp;&nbsp;...&nbsp;&nbsp;
<BR>&nbsp;&nbsp;stock(const&nbsp;string&amp;,&nbsp;const&nbsp;int&amp;,&nbsp;const&nbsp;double&amp;,&nbsp;&nbsp;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;double&amp;,&nbsp;const&nbsp;MysqlDate&amp;);&nbsp;&nbsp;
<BR>&nbsp;&nbsp;set(const&nbsp;string&amp;,&nbsp;const&nbsp;int&amp;,&nbsp;const&nbsp;double&amp;,&nbsp;&nbsp;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;double&amp;,&nbsp;const&nbsp;MysqlDate&amp;);&nbsp;&nbsp;
<BR>}&nbsp;</TT>
</DD>
</DL> 
<P>

<H1><A NAME="SECTION03440000000000000000">
7.4 sql_create_basic General Format </A>
</H1>

<P>
Thus the general format for sql_create_basic is 

<P>

<DL COMPACT>
<DT>
<DD><TT>sql_create_basic_#(NAME,&nbsp;CMP,&nbsp;CNST,&nbsp;TYPE1,&nbsp;ITEM1,&nbsp;...,&nbsp;TYPE#,&nbsp;ITEM#)&nbsp;&nbsp;</TT>
</DD>
</DL> Where: 

<P>

<UL>
<LI># is the number of valuables in the vector 
</LI>
<LI>NAME is the name of the structure you wish to create 
</LI>
<LI>CMP is the number that tells c++, if not set to 0, that if the first
cmp variables are the same then the two structures are the same. 
</LI>
<LI>CNST is the number, if not set to 0, that will create a constructor
which will populate the first n variables. 
</LI>
<LI>TYPE1 is the type name for first item and ITEM1 is the valuables name
for the first item etc.. 
</LI>
</UL>

<P>

<H1><A NAME="SECTION03450000000000000000">
7.5 sql_create_basic_c_order </A>
</H1>

<P>
You can also specify an alternate order for when mysql populates the
 structure. For example: 

<P>

<DL COMPACT>
<DT>
<DD><TT>sql_create_basic_c_order_5(stock,&nbsp;2,&nbsp;5,&nbsp;&nbsp;&nbsp;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MysqlDate,&nbsp;date,&nbsp;5,&nbsp;//&nbsp;type,&nbsp;id,&nbsp;order&nbsp;&nbsp;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double,&nbsp;price,&nbsp;4,&nbsp;&nbsp;&nbsp;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;string,&nbsp;item,&nbsp;1,&nbsp;&nbsp;&nbsp;&nbsp;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int,&nbsp;num,&nbsp;2,&nbsp;&nbsp;&nbsp;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double,&nbsp;weight,&nbsp;3)&nbsp;</TT>
</DD>
</DL> This will create a similar structure as in the previous example except
that that the order of the data items will be different and c++ will
use the first two items to compare with (date, price).  However because
a custom order is specified you can use the same query to populate
the set. It will fill <TT>date</TT> with the first 5th item of the
query result set, <TT>price</TT> with the 4th, etc... 

<P>

<H1><A NAME="SECTION03460000000000000000">
7.6 sql_create_basic_c_order General Format </A>
</H1>

<P>
Thus the general format for sql_create_basic is 

<P>

<DL COMPACT>
<DT>
<DD><TT>sql_create_basic_c_order_#&nbsp;(NAME,&nbsp;CMP,&nbsp;CNST,&nbsp;&nbsp;&nbsp;&nbsp;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TYPE1,&nbsp;ITEM1,&nbsp;ORDER1,&nbsp;&nbsp;&nbsp;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...&nbsp;&nbsp;&nbsp;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TYPE#,&nbsp;ITEM#,&nbsp;ORDER#)&nbsp;</TT>
</DD>
</DL> Where: 

<P>

<UL>
<LI># is the number of valuables in the vector 
</LI>
<LI>NAME is the name of the structure you wish to create 
</LI>
<LI>CMP is the number that tells c++, if not set to 0, that if the first
cmp variables are the same then the two structures are the same. 
</LI>
<LI>CNST is the number, if not set to 0, that will create a constructor
which will populate the first n variables. 
</LI>
<LI>TYPE1 is the type name for first item, ITEM1 is the valuable name
for the first item, ORDER1 is the order number for the first item
...etc... 
</LI>
</UL>

<P>

<H1><A NAME="SECTION03470000000000000000">
7.7 sql_create </A>
</H1>

<P>
In addition to the basic structures you can set up enhanced structures
that  also have methods defined to aid in the creation of queries
and in the insertion of data in tables. 

<P>
For example: 

<P>

<DL COMPACT>
<DT>
<DD><TT>sql_create_5(stock,&nbsp;1,&nbsp;5,&nbsp;&nbsp;&nbsp;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;string,&nbsp;item,&nbsp;//&nbsp;type,&nbsp;id,&nbsp;&nbsp;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int,&nbsp;num,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double,&nbsp;weight,&nbsp;&nbsp;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double,&nbsp;price,&nbsp;&nbsp;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MysqlDate,&nbsp;date)&nbsp;</TT>
</DD>
</DL> which will, in addition to that which is defined in sql_create_basic
with Additional Constructor, define the equivalent to: 

<P>

<DL COMPACT>
<DT>
<DD><TT>struct&nbsp;stock&nbsp;{&nbsp;&nbsp;&nbsp;
<BR>&nbsp;&nbsp;...&nbsp;&nbsp;
<BR>&nbsp;&nbsp;static&nbsp;char&nbsp;*names[];&nbsp;&nbsp;
<BR>&nbsp;&nbsp;static&nbsp;char&nbsp;*table;&nbsp;&nbsp;
<BR>&nbsp;&nbsp;template&nbsp;&lt;class&nbsp;Manip&gt;&nbsp;&nbsp;&nbsp;
<BR>&nbsp;&nbsp;stock_value_list&lt;Manip&gt;&nbsp;value_list(cchar&nbsp;*d&nbsp;=&nbsp;&#34;,&#34;,&nbsp;&nbsp;//&nbsp;basic&nbsp;form&nbsp;&nbsp;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Manip&nbsp;m&nbsp;=&nbsp;mysql_quote)&nbsp;const;&nbsp;&nbsp;
<BR>&nbsp;&nbsp;template&nbsp;&lt;class&nbsp;Manip&gt;&nbsp;&nbsp;&nbsp;
<BR>&nbsp;&nbsp;stock_field_list&lt;Manip&gt;&nbsp;field_list(cchar&nbsp;*d&nbsp;=&nbsp;&#34;,&#34;,&nbsp;&nbsp;&nbsp;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Manip&nbsp;m&nbsp;=&nbsp;mysql_do_nothing)&nbsp;const;&nbsp;&nbsp;
<BR>&nbsp;&nbsp;template&nbsp;&lt;class&nbsp;Manip&gt;&nbsp;&nbsp;&nbsp;
<BR>&nbsp;&nbsp;stock_equal_list&lt;Manip&gt;&nbsp;equal_list(cchar&nbsp;*d&nbsp;=&nbsp;&#34;,&#34;,
</TT>
<P>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cchar&nbsp;*e&nbsp;=&nbsp;&#34;&nbsp;=&nbsp;&#34;,&nbsp;&nbsp;&nbsp;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Manip&nbsp;m&nbsp;=&nbsp;mysql_quote,&nbsp;&nbsp;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)&nbsp;const;&nbsp;&nbsp;
<BR>&nbsp;&nbsp;
<BR>&nbsp;&nbsp;template&nbsp;&lt;class&nbsp;Manip&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;bool&nbsp;form&nbsp;&nbsp;&nbsp;&nbsp;
<BR>&nbsp;&nbsp;stock_cus_value_list&lt;Manip&gt;&nbsp;value_list([cchar&nbsp;*d,&nbsp;[Manip&nbsp;m,]&nbsp;]&nbsp;&nbsp;&nbsp;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bool&nbsp;i1,&nbsp;&nbsp;&nbsp;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bool&nbsp;i2&nbsp;=&nbsp;false,&nbsp;...&nbsp;,&nbsp;&nbsp;&nbsp;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bool&nbsp;i5&nbsp;=&nbsp;false)&nbsp;const;&nbsp;&nbsp;
<BR>&nbsp;&nbsp;template&nbsp;&lt;class&nbsp;Manip&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;list&nbsp;form&nbsp;&nbsp;
<BR>&nbsp;&nbsp;stock_cus_value_list&lt;Manip&gt;&nbsp;value_list([cchar&nbsp;*d,&nbsp;[Manip&nbsp;m,]&nbsp;]&nbsp;&nbsp;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stock_enum&nbsp;i1,&nbsp;&nbsp;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stock_enum&nbsp;i2&nbsp;=&nbsp;stock_NULL,&nbsp;...,&nbsp;&nbsp;&nbsp;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stock_enum&nbsp;i5&nbsp;=&nbsp;stock_NULL)&nbsp;const;&nbsp;&nbsp;
<BR>&nbsp;&nbsp;template&nbsp;&lt;class&nbsp;Manip&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;vector&nbsp;form&nbsp;&nbsp;
<BR>&nbsp;&nbsp;stock_cus_value_list&lt;Manip&gt;&nbsp;value_list([cchar&nbsp;*d,&nbsp;[Manip&nbsp;m,]&nbsp;]&nbsp;&nbsp;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vector&lt;bool&gt;&nbsp;*i)&nbsp;const;&nbsp;&nbsp;
<BR>&nbsp;&nbsp;
<BR>&nbsp;&nbsp;...(The&nbsp;logical&nbsp;equivalent&nbsp;for&nbsp;field_list&nbsp;and&nbsp;equal_list)...&nbsp;&nbsp;
<BR>};&nbsp;</TT>
</DD>
</DL> <B>value_list()</B> returns a special class that when used with
the &lt;&lt; operator with an ostream on the left will
return a comma separated list with values properly quoted and escaped
when needed. 

<P>
<B>field_list()</B> return a special class than does the same thing
but returns  a list of fields that the structure holds which in this
case is the same thing as the valuable names.  The field names are
not escaped or quoted 

<P>
<B>equal_list()</B> returns a comma separated list with the format
 <B>field name = value</B>. The field name is not quoted or escaped
and value is escaped or quoted as needed. 

<P>
For example: 

<P>

<DL COMPACT>
<DT>
<DD><TT>stock&nbsp;s(&#34;Dinner&nbsp;Roles&#34;,75,0.95,0.97,&#34;1998-05-25&#34;);&nbsp;&nbsp;&nbsp;
<BR>
cout&nbsp;&lt;&lt;&nbsp;&#34;Value&nbsp;List:&nbsp;&#34;&nbsp;&lt;&lt;&nbsp;s.comma_list()&nbsp;&lt;&lt;&nbsp;endl;&nbsp;&nbsp;
<BR>
cout&nbsp;&lt;&lt;&nbsp;&#34;Field&nbsp;List:&nbsp;&#34;&nbsp;&lt;&lt;&nbsp;s.field_list()&nbsp;&lt;&lt;&nbsp;endl;&nbsp;&nbsp;
<BR>
cout&nbsp;&lt;&lt;&nbsp;&#34;Equal&nbsp;List:&nbsp;&#34;&nbsp;&lt;&lt;&nbsp;s.equal_list()&nbsp;&lt;&lt;&nbsp;endl;&nbsp;</TT>
</DD>
</DL> Would return something like (with a little extra hand formating): 

<P>

<DL COMPACT>
<DT>
<DD><TT>Value&nbsp;List:&nbsp;'Dinner&nbsp;Roles',75,0.95,0.97,'1998-05-25'&nbsp;&nbsp;&nbsp;
<BR>
Field&nbsp;List:&nbsp;item,num,weight,price,date&nbsp;&nbsp;
<BR>
Equal&nbsp;List:&nbsp;item&nbsp;=&nbsp;'Dinner&nbsp;Roles',num&nbsp;=&nbsp;75,weight&nbsp;=&nbsp;0.95,&nbsp;&nbsp;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;price&nbsp;=&nbsp;0.97,date&nbsp;=&nbsp;'1998-05-25'&nbsp;</TT>
</DD>
</DL> A combination of the field and value list can be used for insert or
replace queries.  For example: 

<P>

<DL COMPACT>
<DT>
<DD><TT>query&nbsp;&lt;&lt;&nbsp;&#34;insert&nbsp;into&nbsp;stock&nbsp;(&#34;&nbsp;&lt;&lt;&nbsp;s.field_list()&nbsp;&#34;)&nbsp;values&nbsp;&#34;&nbsp;&nbsp;&nbsp;&nbsp;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt;&nbsp;s.value_list();&nbsp;</TT>
</DD>
</DL> will insert <TT>s</TT> into table stock. 

<P>
You can also use SQLQuery::insert or SQLQuery::replace (and thus Query::insert
or Query::replace) as a short cut to accomplish the same task like
so: 

<P>

<DL COMPACT>
<DT>
<DD><TT>query.insert(s);</TT>
</DD>
</DL> It will use s.table for the table name which defaults to the name
of the structure. 

<P>
You can also specify an different delimiter &#34;d&#34;.
 If none is specified it defaults to &#34;,&#34;.  With
this you can use the delimiter &#34; AND &#34; for equal_list
to aid in update and select queries.  For example: 

<P>

<DL COMPACT>
<DT>
<DD><TT>stock&nbsp;s2&nbsp;=&nbsp;s;&nbsp;&nbsp;&nbsp;&nbsp;
<BR>
s2.item&nbsp;=&nbsp;&#34;6&nbsp;Dinner&nbsp;Roles&#34;;&nbsp;&nbsp;
<BR>
query&nbsp;&lt;&lt;&nbsp;&#34;UPDATE&nbsp;TABLE&nbsp;stock&nbsp;SET&nbsp;&#34;&nbsp;&lt;&lt;&nbsp;s2.equal_list()&nbsp;&nbsp;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt;&nbsp;&#34;&nbsp;WHERE&nbsp;&#34;&nbsp;&lt;&lt;&nbsp;s.equal_list(&#34;&nbsp;AND&nbsp;&#34;);&nbsp;</TT>
</DD>
</DL> would produce the query: 

<P>

<DL COMPACT>
<DT>
<DD><TT>UPDATE&nbsp;TABLE&nbsp;stock&nbsp;SET&nbsp;item&nbsp;=&nbsp;'6&nbsp;Dinner&nbsp;Roles',num&nbsp;=&nbsp;75,weight&nbsp;=&nbsp;0.95,&nbsp;&nbsp;&nbsp;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;price&nbsp;=&nbsp;0.97,date&nbsp;=&nbsp;'1998-05-25'&nbsp;&nbsp;&nbsp;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WHERE&nbsp;item&nbsp;=&nbsp;'Dinner&nbsp;Roles'&nbsp;AND&nbsp;num&nbsp;=&nbsp;75&nbsp;&nbsp;&nbsp;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AND&nbsp;weight&nbsp;=&nbsp;0.95&nbsp;AND&nbsp;price&nbsp;=&nbsp;0.97&nbsp;&nbsp;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AND&nbsp;date&nbsp;=&nbsp;'1998-05-25'&nbsp;</TT>
</DD>
</DL> which will change the entree in the table so that item is now &#34;6
Dinner Roles&#34; instead of &#34;Dinner Roles&#34; 

<P>
You can use <B>SQLQuery::update</B> (and thus <B>Query::update</B>)
as a short cut to accomplishing the same task like so: 

<P>

<DL COMPACT>
<DT>
<DD><TT>stock&nbsp;s2&nbsp;=&nbsp;s;&nbsp;&nbsp;&nbsp;&nbsp;
<BR>
s2.item&nbsp;=&nbsp;&#34;6&nbsp;Dinner&nbsp;Roles&#34;;&nbsp;&nbsp;
<BR>
query.update(s,s2);&nbsp;</TT>
</DD>
</DL> Like <B>SQLQuery::insert</B>, it will use s.table for the table
name which defaults to the name of the structure. 

<P>
You can also specify an different manipulator which will effect the
way c++ quotes or escapes the values.  This may be any valid stream
manipulator that only effects the item to the right of manipulator.
<B>value_list</B> and <B>equal_list</B> defaults to <B>escape</B>
and <B>field_list</B> defaults to <B>do_nothing</B>.  For <B>equal_list</B>
the manipulator only effects the <B>value</B> part and not the <B>field
name</B> part. 

<P>
This can be useful creating exporting to a file where you don't want
quotes around strings for example. 

<P>

<DL COMPACT>
<DT>
<DD><TT>table_out&nbsp;&lt;&lt;&nbsp;q.value_list(&#34;&#92;&nbsp;t&#34;,&nbsp;mysql_escape)&nbsp;&lt;&lt;&nbsp;endl;</TT>
</DD>
</DL> will append data to the file handle table_out. 

<P>
The three non-basic forms allow you to specify which items are returned.
For example: 

<P>

<DL COMPACT>
<DT>
<DD><TT>cout&nbsp;&lt;&lt;&nbsp;q.value_list(false,false,true,true,false)&nbsp;&lt;&lt;&nbsp;endl;&nbsp;//bool&nbsp;form&nbsp;&nbsp;&nbsp;
<BR>
cout&nbsp;&lt;&lt;&nbsp;q.value_list(stock_weight,&nbsp;stock_price)&nbsp;&lt;&lt;&nbsp;endl;&nbsp;&nbsp;&nbsp;//list&nbsp;form&nbsp;</TT>
</DD>
</DL> will both return: 

<P>

<DL COMPACT>
<DT>
<DD><TT>0.95,0.97&nbsp;&nbsp;</TT>
</DD>
</DL> The <I>bool form</I> excepts boolean arguments where each true/false
represents an wether to show a valuable.  False means not to show
it while true means  to show it. If you leave of some they are assumed
to be false.  For example: 

<P>

<DL COMPACT>
<DT>
<DD><TT>cout&nbsp;&lt;&lt;&nbsp;q.value_list(false,false,true,true)&nbsp;&lt;&lt;&nbsp;endl;&nbsp;&nbsp;</TT>
</DD>
</DL> is the same as the above example.   

<P>
The <I>list form</I> allows you to specify which items to show.
 An enum values are created for each valuable with the name of struct
plus the underscore character prefixed before it.  For example:  item
becomes stock_item. 

<P>
These forms can be useful is select queries.  For example: 

<P>

<DL COMPACT>
<DT>
<DD><TT>query&nbsp;&lt;&lt;&nbsp;&#34;SELECT&nbsp;*&nbsp;FROM&nbsp;stock&nbsp;WHERE&nbsp;&#34;&nbsp;
</TT>
<P>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt;&nbsp;q.equal_list(&#34;&nbsp;AND&nbsp;&#34;,stock_weight,stock_price);&nbsp;</TT>
</DD>
</DL> would produce the query: 

<P>

<DL COMPACT>
<DT>
<DD><TT>SELECT&nbsp;*&nbsp;FROM&nbsp;stock&nbsp;WHERE&nbsp;weight=0.95&nbsp;AND&nbsp;price=0.97&nbsp;&nbsp;</TT>
</DD>
</DL> which will select all rows from stock which have the same weight and
price as <I>q</I>. 

<P>
The <I>vector form</I> (not shown above) allows you to pass a boolean
vector which is a time saver if you use the some pattern more than
once as it avoids having to create the vector from the arguments each
time.  If <TT>a</TT> is a boolean vector then <TT>a[0]</TT> will
hold wether to include the first variable <TT>a[1]</TT> the second
etc...  For example: 

<P>

<DL COMPACT>
<DT>
<DD><TT>vector&lt;bool&gt;&nbsp;a;&nbsp;&nbsp;&nbsp;
<BR>
a[0]&nbsp;=&nbsp;false;&nbsp;a[1]&nbsp;=&nbsp;false;&nbsp;a[2]&nbsp;=&nbsp;true;&nbsp;a[3]&nbsp;=&nbsp;true;&nbsp;a[4]&nbsp;=&nbsp;false;&nbsp;&nbsp;
<BR>
query&nbsp;&lt;&lt;&nbsp;&#34;SELECT&nbsp;*&nbsp;FROM&nbsp;stock&nbsp;WHERE&nbsp;&#34;&nbsp;&lt;&lt;&nbsp;q.equal_list(&#34;&nbsp;AND&nbsp;&#34;,&nbsp;a);&nbsp;</TT>
</DD>
</DL> will produce the same query as in the above example. 

<P>

<H1><A NAME="SECTION03480000000000000000">
7.8 sql_create_c_names </A>
</H1>

<P>
You can also specify alternate field names like so: 

<P>

<DL COMPACT>
<DT>
<DD><TT>sql_create_c_names_5(stock,&nbsp;1,&nbsp;5,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;string,&nbsp;item,&nbsp;&#34;item&#34;,&nbsp;//&nbsp;type,&nbsp;id,&nbsp;column&nbsp;name&nbsp;&nbsp;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int,&nbsp;num,&nbsp;&#34;quantity&#34;,&nbsp;&nbsp;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double,&nbsp;weight,&nbsp;&#34;weight&#34;,&nbsp;&nbsp;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double,&nbsp;price,&nbsp;&#34;price&#34;&nbsp;&nbsp;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MysqlDate,&nbsp;date,&nbsp;&#34;shipment&#34;)&nbsp;</TT>
</DD>
</DL> When <B>field_list</B> or <B>equal_list</B> is used it will
use the given  field names rather than the variable names for example: 

<P>

<DL COMPACT>
<DT>
<DD><TT>stock&nbsp;s(&#34;Dinner&nbsp;Roles&#34;,75,0.95,0.97,&#34;1998-05-25&#34;);&nbsp;&nbsp;&nbsp;
<BR>
cout&nbsp;&lt;&lt;&nbsp;&#34;Field&nbsp;List:&nbsp;&#34;&nbsp;&lt;&lt;&nbsp;s.field_list()&nbsp;&lt;&lt;&nbsp;endl;&nbsp;&nbsp;
<BR>
cout&nbsp;&lt;&lt;&nbsp;&#34;Equal&nbsp;List:&nbsp;&#34;&nbsp;&lt;&lt;&nbsp;s.equal_list()&nbsp;&lt;&lt;&nbsp;endl;&nbsp;</TT>
</DD>
</DL> Would return something like (with a little extra hand formating): 

<P>

<DL COMPACT>
<DT>
<DD><TT>Field&nbsp;List:&nbsp;item,quantity,weight,price,shipment&nbsp;&nbsp;&nbsp;
<BR>
Equal&nbsp;List:&nbsp;item&nbsp;=&nbsp;'Dinner&nbsp;Roles',quantity&nbsp;=&nbsp;75,weight&nbsp;=&nbsp;0.95,&nbsp;&nbsp;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;price&nbsp;=&nbsp;0.97,shipment&nbsp;=&nbsp;'1998-05-25'&nbsp;</TT>
</DD>
</DL> 
<P>

<H1><A NAME="SECTION03490000000000000000">
7.9 sql_create_c_names General Format </A>
</H1>

<P>
The general format is: 

<P>

<DL COMPACT>
<DT>
<DD><TT>sql_create_c_names_#&nbsp;(NAME,&nbsp;CMP,&nbsp;CNST,&nbsp;&nbsp;&nbsp;&nbsp;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TYPE1,&nbsp;ITEM1,&nbsp;NAME1,&nbsp;&nbsp;&nbsp;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...&nbsp;&nbsp;&nbsp;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TYPE#,&nbsp;ITEM#,&nbsp;NAME#)&nbsp;</TT>
</DD>
</DL> where NAME1 is the name of the first field, etc.  Everything else
is the same as it is the same as in sql_create_basic_c_order General
Format. 

<P>

<H1><A NAME="SECTION034100000000000000000">
7.10 sql_create_c_order </A>
</H1>

<P>
As in sql_create_basic_c_order you may specify a custom order.
The general from is: 

<P>

<DL COMPACT>
<DT>
<DD><TT>sql_create_c_order_#&nbsp;(NAME,&nbsp;CMP,&nbsp;CNST,&nbsp;&nbsp;&nbsp;&nbsp;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TYPE1,&nbsp;ITEM1,&nbsp;ORDER1,&nbsp;&nbsp;&nbsp;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...&nbsp;&nbsp;&nbsp;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TYPE#,&nbsp;ITEM#,&nbsp;ORDER#)&nbsp;</TT>
</DD>
</DL> where everything is the same as in  sql_create_basic_c_order General
Format. 

<P>

<H1><A NAME="SECTION034110000000000000000">
7.11 sql_create_complete </A>
</H1>

<P>
You can also specify both a custom order and custom field names.   The
general from is. 

<P>

<DL COMPACT>
<DT>
<DD><TT>sql_create_complete_#&nbsp;(NAME,&nbsp;CMP,&nbsp;CNST,&nbsp;&nbsp;&nbsp;&nbsp;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TYPE1,&nbsp;ITEM1,&nbsp;NAME1,&nbsp;ORDER1,&nbsp;&nbsp;&nbsp;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...&nbsp;&nbsp;&nbsp;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TYPE#,&nbsp;ITEM#,&nbsp;NAME#,&nbsp;ORDER#)&nbsp;</TT>
</DD>
</DL> Where everything is the same as in  sql_create_c_order General
Format and sql_create_c_names General Format. 

<P>

<H1><A NAME="SECTION034120000000000000000">
7.12 Changing the table name </A>
</H1>

<P>
In order to avoid having even more forms  we decided not to allow
you to specify a different table name in the actual macro call. The
table name is used by <B>SQLQuery::insert</B>, <B>replace</B>,
and <B>update</B>.  However you can easeally change the default
table name, which is the same as the struct name, by changing the
reference <B>NAME::table()</B> returns to a different <B>const
char *</B>  For example: 

<P>

<DL COMPACT>
<DT>
<DD><TT>stock::table()&nbsp;=&nbsp;&#34;in_stock&#34;&nbsp;&nbsp;</TT>
</DD>
</DL> Will change the table name to &#34;in_stock&#34; in the
examples used through out this guide. 

<P>

<H1><A NAME="SECTION034130000000000000000">
7.13 Seeing the actual code </A>
</H1>

<P>
To see the actual code that the macro inserts use sql++pretty.  For
example: 

<P>

<DL COMPACT>
<DT>
<DD><TT>sql++pretty&nbsp;&lt;&nbsp;test.cc&nbsp;|&nbsp;less&nbsp;&nbsp;</TT>
</DD>
</DL> 
<P>

<H1><A NAME="SECTION034140000000000000000">
7.14 Adding functionality </A>
</H1>

<P>
The best way to add functionality is through inheritance.  Even though
you could paste the code outputted from pretty.pl and modify it this
is not recommended because it won't reflect future enhancements. 

<P>

<H1><A NAME="SECTION034150000000000000000">
7.15 Other notes </A>
</H1>

<P>
Macros are defined for structures with up to 25 items.  If you need
more  modify the underlying perl script custom.pl. This perl script
is used to generate the header file. It in no way tries to parse C++
code. 

<P>
The header file that the script custom.pl creates is close to a meg.
However, please note that the 1 meg header file (custom-macros.hh)
is NOTHING but macros.  Therefor the compiler has to do very little
work when reading is. 

<P>
Also, everything included by the macro call is done in such a way
that you can safely include the macro call in a header file and not
have to worry about duplicate function calls or anything of the like. 

<P>
<HR>
<!--Navigation Panel-->
<A NAME="tex2html389"
  HREF="8_Long.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html385"
  HREF="Usage.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html379"
  HREF="6_Template.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html387"
  HREF="Contents.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A>  
<BR>
<B> Next:</B> <A NAME="tex2html390"
  HREF="8_Long.html">8. Long Names</A>
<B> Up:</B> <A NAME="tex2html386"
  HREF="Usage.html">Usage</A>
<B> Previous:</B> <A NAME="tex2html380"
  HREF="6_Template.html">6. Template Queries</A>
 &nbsp <B>  <A NAME="tex2html388"
  HREF="Contents.html">Contents</A></B> 
<!--End of Navigation Panel-->
<ADDRESS>

2001-05-01
</ADDRESS>
</BODY>
</HTML>
