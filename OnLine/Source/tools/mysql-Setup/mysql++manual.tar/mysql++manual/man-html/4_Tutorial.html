<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">

<!--Converted with LaTeX2HTML 99.2beta8 (1.43)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>4. Tutorial by Example</TITLE>
<META NAME="description" CONTENT="4. Tutorial by Example">
<META NAME="keywords" CONTENT="manual">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<META NAME="Generator" CONTENT="LaTeX2HTML v99.2beta8">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="manual.css">

<LINK REL="next" HREF="5_Class.html">
<LINK REL="previous" HREF="Usage.html">
<LINK REL="up" HREF="Usage.html">
<LINK REL="next" HREF="5_Class.html">
</HEAD>

<BODY >
<!--Navigation Panel-->
<A NAME="tex2html326"
  HREF="5_Class.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html322"
  HREF="Usage.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html316"
  HREF="Usage.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html324"
  HREF="Contents.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A>  
<BR>
<B> Next:</B> <A NAME="tex2html327"
  HREF="5_Class.html">5. Class Reference</A>
<B> Up:</B> <A NAME="tex2html323"
  HREF="Usage.html">Usage</A>
<B> Previous:</B> <A NAME="tex2html317"
  HREF="Usage.html">Usage</A>
 &nbsp <B>  <A NAME="tex2html325"
  HREF="Contents.html">Contents</A></B> 
<BR>
<BR>
<!--End of Navigation Panel-->
<!--Table of Child-Links-->
<A NAME="CHILD_LINKS"><STRONG>Subsections</STRONG></A>

<UL>
<LI><A NAME="tex2html328"
  HREF="4_Tutorial.html#SECTION03110000000000000000">4.1 Introduction</A>
<LI><A NAME="tex2html329"
  HREF="4_Tutorial.html#SECTION03120000000000000000">4.2 Assumptions</A>
<LI><A NAME="tex2html330"
  HREF="4_Tutorial.html#SECTION03130000000000000000">4.3 Running the Examples</A>
<LI><A NAME="tex2html331"
  HREF="4_Tutorial.html#SECTION03140000000000000000">4.4 The Basics</A>
<UL>
<LI><A NAME="tex2html332"
  HREF="4_Tutorial.html#SECTION03141000000000000000">4.4.1 A Simple Example</A>
<LI><A NAME="tex2html333"
  HREF="4_Tutorial.html#SECTION03142000000000000000">4.4.2 A slightly more complicated example</A>
<LI><A NAME="tex2html334"
  HREF="4_Tutorial.html#SECTION03143000000000000000">4.4.3 Getting Info about the Fields</A>
</UL>
<LI><A NAME="tex2html335"
  HREF="4_Tutorial.html#SECTION03150000000000000000">4.5 Specialized SQL Structures</A>
<UL>
<LI><A NAME="tex2html336"
  HREF="4_Tutorial.html#SECTION03151000000000000000">4.5.1 Retrieving Data</A>
<LI><A NAME="tex2html337"
  HREF="4_Tutorial.html#SECTION03152000000000000000">4.5.2 Adding Data </A>
<LI><A NAME="tex2html338"
  HREF="4_Tutorial.html#SECTION03153000000000000000">4.5.3 Modifying Data </A>
<LI><A NAME="tex2html339"
  HREF="4_Tutorial.html#SECTION03154000000000000000">4.5.4 Less-Than-Comparable</A>
</UL>
<LI><A NAME="tex2html340"
  HREF="4_Tutorial.html#SECTION03160000000000000000">4.6 Let us be usefull</A>
<UL>
<LI><A NAME="tex2html341"
  HREF="4_Tutorial.html#SECTION03161000000000000000">4.6.1 Loading binary file in a BLOB column</A>
<LI><A NAME="tex2html342"
  HREF="4_Tutorial.html#SECTION03162000000000000000">4.6.1 Displaying images in HTML from BLOB column</A>
<LI><A NAME="tex2html343"
  HREF="4_Tutorial.html#SECTION03163000000000000000">4.6.2 Delete or Update from Select</A>
<LI><A NAME="tex2html344"
  HREF="4_Tutorial.html#SECTION03164000000000000000">4.6.2 And There's More</A>
</UL>
<LI><A NAME="tex2html345"
  HREF="4_Tutorial.html#SECTION03170000000000000000">4.7 Template Queries</A>
</UL>
<!--End of Table of Child-Links-->
<HR>

<H1><A NAME="SECTION03100000000000000000">
4. Tutorial by Example</A>
</H1>

<P>

<H1><A NAME="SECTION03110000000000000000">
4.1 Introduction</A>
</H1>

<P>
This tutorial is meant to give you a jump start into using my API.
My Mysql++ API is a very complicated being with a lot of advance features
that you can due without if all you want to do is execute simple queries.

<P>

<H1><A NAME="SECTION03120000000000000000">
4.2 Assumptions</A>
</H1>

<P>
This tutorial assumes you know C++ fairly well, inparticuler it assumes
you know about the Standard Template Library (STL) and exceptions.

<P>

<H1><A NAME="SECTION03130000000000000000">
4.3 Running the Examples</A>
</H1>

<P>
All of the example code form complete running programs. However in
order to use them you need to first compile them my switching to the
examples directory and typing in <TT>make</TT>. Then you need to set
up the database by running reset-db. The usage of the reset-db program
is as follows.

<P>

<DL COMPACT>
<DT>
<DD><TT>reset-db&nbsp;[host&nbsp;[user&nbsp;[password]]]</TT>
</DD>
</DL> If you leave off host localhost is assumed. If you leave off user
your current username is assumed. If you leave of the password it
is assumed that you don't need one.

<P>
When you first run the program you need to give it an account with
permission to create databases. Once the database is created you can
use any account that has permission full permission to the database
mysql_cpp_data. 

<P>
You should also run the reset-db program between examples that modify
the data or else things might not work right.

<P>

<H1><A NAME="SECTION03140000000000000000">
4.4 The Basics</A>
</H1>

<P>

<H2><A NAME="SECTION03141000000000000000">
4.4.1 A Simple Example</A>
</H2>

<P>
The following example demonstrates how to open a connection, execute
a simple query, and display the results. The code can be found in
the file <TT>simple1.cc</TT> which is located in the examples directory.

<P>
#include &lt;iostream&gt; 
<BR>#include &lt;iomanip&gt; 
<BR>#include &lt;sqlplus.hh&gt;
<BR>&nbsp;
<BR>
int main() {
<BR>&nbsp; Connection con(&#34;mysql_cpp_data&#34;);
<BR>&nbsp; // The full format for the Connection constructor is
<BR>&nbsp; // Connection(cchar *db, cchar *host=&#34;&#34;,

<BR>&nbsp; //&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cchar *user=&#34;&#34;, cchar
*passwd=&#34;&#34;) 
<BR>&nbsp; // You may need to specify some of them if the database is not
on
<BR>&nbsp; // the local machine or you database username is not the same as
your
<BR>&nbsp; // login name, etc..
<BR>&nbsp;
<BR>&nbsp; Query query = con.query();
<BR>&nbsp; // This creates a query object that is bound to con.
<BR>&nbsp;
<BR>&nbsp; query &lt;&lt; &#34;select * from stock&#34;;
<BR>&nbsp; // You can write to the query object like you would any other ostrem
<BR>&nbsp;
<BR>&nbsp; Result res = query.store();
<BR>&nbsp; // Query::store() executes the query and returns the results
<BR>&nbsp;
<BR>&nbsp; cout &lt;&lt; &#34;Query: &#34; &lt;&lt;
query.preview() &lt;&lt; endl;
<BR>&nbsp; // Query::preview() simply returns a string with the current query
<BR>&nbsp; // string in it.
<BR>&nbsp;
<BR>&nbsp; cout &lt;&lt; &#34;Records Found: &#34;
&lt;&lt; res.size() &lt;&lt; endl &lt;&lt;
endl;
<BR>&nbsp; 
<BR>&nbsp; Row row;
<BR>&nbsp; cout.setf(ios::left);
<BR>&nbsp; cout &lt;&lt; setw(17) &lt;&lt; &#34;Item&#34;

<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; setw(4)&nbsp; &lt;&lt;
&#34;Num&#34;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; setw(7)&nbsp; &lt;&lt;
&#34;Weight&#34;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; setw(7)&nbsp; &lt;&lt;
&#34;Price&#34; 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; &#34;Date&#34; &lt;&lt;
endl
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; endl;
<BR>&nbsp; 
<BR>&nbsp; Result::iterator i;
<BR>&nbsp; // The Result class has a read-only Random Access Iterator
<BR>&nbsp; for (i = res.begin(); i != res.end(); i++) {
<BR>&nbsp;&nbsp;&nbsp; row = *i;
<BR>&nbsp;&nbsp;&nbsp; cout &lt;&lt; setw(17) &lt;&lt; row[0]

<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; setw(4)&nbsp; &lt;&lt;
row[1] 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; setw(7)&nbsp; &lt;&lt;
row[&#34;weight&#34;]
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // you can use either the index number or column name when
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // retrieving the colume data as demonstrated above.
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; setw(7)&nbsp; &lt;&lt;
row[3]
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; row[4] &lt;&lt;
endl;
<BR>&nbsp; }
<BR>&nbsp; return 0;
<BR>}

<P>
Everything here should be fairly obvious. Take particular notice of
how  we used an iterator with the result set.

<P>

<H2><A NAME="SECTION03142000000000000000">
4.4.2 A slightly more complicated example</A>
</H2>

<P>
This example is almost like the previous one however it uses exceptions
and the automatic conversion feature of <B>ColData</B>. Pay particular
notice to how exceptions are used. This file for this code is named
<TT>complic1.cc</TT>.

<P>
#include &lt;iostream&gt;
<BR>#include &lt;iomanip&gt;
<BR>#include &lt;sqlplus.hh&gt;
<BR>&nbsp;
<BR>
int main() {
<BR>&nbsp; try { // its in one big try block
<BR>&nbsp;
<BR>&nbsp;&nbsp;&nbsp; Connection con(use_exceptions);
<BR>&nbsp;&nbsp;&nbsp; con.connect(&#34;mysql_cpp_data&#34;);
<BR>&nbsp;&nbsp;&nbsp; // Here  we broke making the connection into two calls.
<BR>&nbsp;&nbsp;&nbsp; // The first one creates the Connection object with the 
<BR>&nbsp;&nbsp;&nbsp; // use exceptions option turned on and the second one
<BR>&nbsp;&nbsp;&nbsp; // makes the connection
<BR>&nbsp;&nbsp;&nbsp; 
<BR>&nbsp;&nbsp;&nbsp; Query query = con.query();
<BR>&nbsp;&nbsp;&nbsp; 
<BR>&nbsp;&nbsp;&nbsp; query &lt;&lt; &#34;select * from stock&#34;;
<BR>&nbsp;&nbsp;&nbsp; Result res = query.store();
<BR>&nbsp;&nbsp;&nbsp; 
<BR>&nbsp;&nbsp;&nbsp; cout &lt;&lt; &#34;Query: &#34; &lt;&lt;
query.preview() &lt;&lt; endl;
<BR>&nbsp;&nbsp;&nbsp; cout &lt;&lt; &#34;Records Found: &#34;
&lt;&lt; res.size() &lt;&lt; endl &lt;&lt;
endl;
<BR>&nbsp;&nbsp;&nbsp; 
<BR>&nbsp;&nbsp;&nbsp; Row row;
<BR>&nbsp;&nbsp;&nbsp; cout.setf(ios::left);
<BR>&nbsp;&nbsp;&nbsp; cout &lt;&lt; setw(17) &lt;&lt; &#34;Item&#34;

<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; setw(4)&nbsp; &lt;&lt;
&#34;Num&#34;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; setw(7)&nbsp; &lt;&lt;
&#34;Weight&#34;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; setw(7)&nbsp; &lt;&lt;
&#34;Price&#34; 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; &#34;Date&#34; &lt;&lt;
endl
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; endl;
<BR>&nbsp; 
<BR>&nbsp;&nbsp;&nbsp; Result::iterator i;
<BR>&nbsp;&nbsp;&nbsp; 
<BR>&nbsp;&nbsp;&nbsp; cout.precision(3);
<BR>&nbsp;&nbsp;&nbsp; for (i = res.begin(); i != res.end(); i++) {
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; row = *i;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; setw(17) &lt;&lt;
row[&#34;item&#34;] &lt;&lt; setw(4) &lt;&lt;
row[1] 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; setw(7)&nbsp; &lt;&lt;
(double)row[2]
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// This is converting the row to a double so that
we
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// can set the precision of it.&nbsp; 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// ColData has the nice feature that it will convert
to
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// any of the basic c++ types.&nbsp; if there is a problem
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// in the conversion it will throw an exception (which
 we 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// cache below).&nbsp; To test it try changing the 2 in
row[2]
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// to row[0]
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; setw(7) &lt;&lt;
(double)row[3];
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Date date = row[&#34;sdate&#34;]; 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // The ColData is implicitly converted to a date here.
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout.setf(ios::right);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout.fill('0');
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; setw(2) &lt;&lt;
date.month &lt;&lt; &#34;-&#34; &lt;&lt;
setw(2) &lt;&lt; date.day &lt;&lt; endl;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout.fill(' ');
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout.unsetf(ios::right);
<BR>&nbsp;&nbsp;&nbsp; }
<BR>&nbsp;&nbsp;&nbsp; return 0;
<BR>&nbsp; } catch (BadQuery er) { // handle any connection or
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // query errors
that may come up
<BR>&nbsp;&nbsp;&nbsp; cerr &lt;&lt; &#34;Error: &#34; &lt;&lt;
er.error &lt;&lt; endl;
<BR>&nbsp;&nbsp;&nbsp; return -1;
<BR>&nbsp; } catch (BadConversion er) { // handle bad conversions
<BR>&nbsp;&nbsp;&nbsp; cerr &lt;&lt; &#34;Error: Tried to convert
&#92;&#34;&#34; &lt;&lt; er.data
&lt;&lt; &#34;&#92;&#34; to a &#92;&#34;&#34;

<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; er.type_name &lt;&lt;
&#34;&#92;&#34;.&#34; &lt;&lt;
endl;
<BR>&nbsp;&nbsp;&nbsp; return -1;
<BR>&nbsp; }
<BR>}

<P>
Everything should be fairly obvious. A few notes about exceptions,
however:

<P>

<OL>
<LI>When the <B>use_exceptions</B> flag is set for a parent object
it is also set for all of its children the it created after the flag
is set. For example when the <B>use_exceptions</B> flag is set
for the <TT>con</TT> object, it is also set for the <TT>query</TT>
object. Please note that the <B>use_exceptions</B> flag is not
linked, it is copied. This means that when you change the <B>use_exceptions</B>
flag only its new children are affected, <I>not</I> the ones it already
created.
</LI>
<LI><B>ColData</B> will always throw an exception when it encounters
a bad conversion. A bad conversion is defined as a conversion in which:
a) All the charters from the string are not read in and b) The remaining
characters are something other than whitespace, zeros (0), or periods
(.). This means that when ``1.25'' is converted into an int an exception
will be thrown however not when ``1.00'' is converted into an int
as the remaining characters are the period and the zero. 
</LI>
</OL>
To see how the exception work try creating an error. Some good things
to try would be misspelling the table name or changing the double
to an int.

<P>

<H2><A NAME="SECTION03143000000000000000">
4.4.3 Getting Info about the Fields</A>
</H2>

<P>
The following example demonstrates how to get some basic information
about the fields, including the name of the field and the SQL type.
The file is called fieldinfo1.cc.

<P>
#include &lt;iostream&gt;
<BR>#include &lt;iomanip&gt;
<BR>#include &lt;sqlplus.hh&gt;
<BR>&nbsp;
<BR>
int main() {
<BR>&nbsp; try { // its in one big try block
<BR>&nbsp;
<BR>&nbsp;&nbsp;&nbsp; Connection con(use_exceptions);
<BR>&nbsp;&nbsp;&nbsp; con.connect(&#34;mysql_cpp_data&#34;);
<BR>&nbsp;&nbsp;&nbsp; Query query = con.query();
<BR>&nbsp;&nbsp;&nbsp; query &lt;&lt; &#34;select * from stock&#34;;
<BR>&nbsp;&nbsp;&nbsp; Result res = query.store();
<BR>&nbsp;&nbsp;&nbsp; 
<BR>&nbsp;&nbsp;&nbsp; cout &lt;&lt; &#34;Query: &#34; &lt;&lt;
query.preview() &lt;&lt; endl;
<BR>&nbsp;&nbsp;&nbsp; cout &lt;&lt; &#34;Records Found: &#34;
&lt;&lt; res.size() &lt;&lt; endl &lt;&lt;
endl;
<BR>&nbsp;
<BR>&nbsp;&nbsp;&nbsp; cout &lt;&lt; &#34;Query Info:&#92;n&#34;;
<BR>&nbsp;&nbsp;&nbsp; cout.setf(ios::left);
<BR>&nbsp;
<BR>&nbsp;&nbsp;&nbsp; for (unsigned int i = 0; i &lt; res.size(); i++) {
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; setw(2)&nbsp; &lt;&lt;
i
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; setw(15) &lt;&lt;
res.names(i).c_str()
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// this is the name of the field
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; setw(15) &lt;&lt;
res.types(i).sql_name()
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// this is the SQL identifier name
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Result::types(unsigned int) returns a mysql_type_info
which in many
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// ways is like type_info except that it has additional
sql type
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// information in it. (with one of the methods being
sql_name())
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; setw(20) &lt;&lt;
res.types(i).name()
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// this is the C++ identifier name which most closely
resembles
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// the sql name (its is implementation defined and
often not very readable)
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; endl;
<BR>&nbsp;&nbsp;&nbsp; }
<BR>&nbsp;
<BR>&nbsp;&nbsp;&nbsp; cout &lt;&lt; endl;
<BR>&nbsp;&nbsp;&nbsp; 
<BR>&nbsp;&nbsp;&nbsp; if (res.types(0) == typeid(string))
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; &#34;Field 'item' is of
an sql type which most closely resembles a&#92;n&#34;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; &#34;the c++ string
type&#92;n&#34;;
<BR>&nbsp;&nbsp;&nbsp; // this is demonstrating how a mysql_type_info can be compared
with a c++
<BR>&nbsp;&nbsp;&nbsp; // type_info.
<BR>&nbsp;
<BR>&nbsp;&nbsp;&nbsp; if (res.types(1) == typeid(short int))
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; &#34;Field 'num' is of
an sql type which most closely resembles a&#92;n&#34;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; &#34;the c++ short
int type&#92;n&#34;;
<BR>&nbsp;&nbsp;&nbsp; else if (res.types(1).base_type() == typeid(short int))
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; &#34;Field 'num' base type
is of an sql type which most closely &#92;n&#34;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; &#34;resembles a the
c++ short int type&#92;n&#34;;
<BR>&nbsp;&nbsp;&nbsp; // However you have to be careful as if it can be null the
actual type is 
<BR>&nbsp;&nbsp;&nbsp; // Null&lt;TYPE&gt; not TYPE.&nbsp; So you should always use the base_type
method
<BR>&nbsp;&nbsp;&nbsp; // to get at the underlying type.&nbsp; If the type is not null
than this base
<BR>&nbsp;&nbsp;&nbsp; // type would be the same as its type.
<BR>&nbsp;&nbsp;&nbsp; 
<BR>&nbsp;&nbsp;&nbsp; return 0;
<BR>&nbsp; } catch (BadQuery er) {
<BR>&nbsp;&nbsp;&nbsp; cerr &lt;&lt; &#34;Error: &#34; &lt;&lt;
er.error &lt;&lt; endl;
<BR>&nbsp;&nbsp;&nbsp; return -1;
<BR>&nbsp; } catch (BadConversion er) { // handle bad conversions
<BR>&nbsp;&nbsp;&nbsp; cerr &lt;&lt; &#34;Error: Tried to convert
&#92;&#34;&#34; &lt;&lt; er.data
&lt;&lt; &#34;&#92;&#34; to a &#92;&#34;&#34;

<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; er.type_name &lt;&lt;
&#34;&#92;&#34;.&#34; &lt;&lt;
endl;
<BR>&nbsp;&nbsp;&nbsp; return -1;
<BR>&nbsp; }
<BR>}
<BR>&nbsp;

<P>

<H1><A NAME="SECTION03150000000000000000">
4.5 Specialized SQL Structures</A>
</H1>

<P>

<H2><A NAME="SECTION03151000000000000000">
4.5.1 Retrieving Data</A>
</H2>

<P>
The next example demonstrates a fairly interesting concept known as
Specialized SQL Structures (SSQLS). The file name for this code is
<TT>custom1.cc</TT>.

<P>
#include &lt;iostream&gt;
<BR>#include &lt;iomanip&gt;
<BR>#include &lt;vector&gt;
<BR>#include &lt;sqlplus.hh&gt;
<BR>#include &lt;custom.hh&gt;
<BR>&nbsp;
<BR>
sql_create_5 (stock,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// struct name, 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1, 5,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// I'll
explain these latter
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; string, item,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// type, id
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int, num,
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double, weight,
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double, price,
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Date, sdate)
<BR>&nbsp;
<BR>// this is calling a very complex macro which will create a custom
<BR>// struct &#34;stock&#34; which has the variables:
<BR>//&nbsp;&nbsp; string item
<BR>//&nbsp;&nbsp;&nbsp; int num
<BR>//&nbsp;&nbsp;&nbsp; ...
<BR>//&nbsp;&nbsp;&nbsp; Date sdate
<BR>// defined as well methods to help populate the class from a mysql
row
<BR>// among other things that I'll get too in a latter example
<BR>&nbsp;
<BR>
int main () {
<BR>&nbsp; try {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// its
in one big try block
<BR>&nbsp;&nbsp;&nbsp; Connection con (use_exceptions);
<BR>&nbsp;&nbsp;&nbsp; con.connect (&#34;mysql_cpp_data&#34;);
<BR>&nbsp;&nbsp;&nbsp; Query query = con.query ();
<BR>&nbsp;&nbsp;&nbsp; query &lt;&lt; &#34;select * from stock&#34;;
<BR>&nbsp;
<BR>&nbsp;&nbsp;&nbsp; vector &lt; stock &gt; res;
<BR>&nbsp;&nbsp;&nbsp; query.storein (res);
<BR>&nbsp;&nbsp;&nbsp; // this is storing the results into a vector of the custom
struct
<BR>&nbsp;&nbsp;&nbsp; // &#34;stock&#34; which was created my the macro
above.
<BR>&nbsp;
<BR>&nbsp;&nbsp;&nbsp; cout.setf (ios::left);
<BR>&nbsp;&nbsp;&nbsp; cout &lt;&lt; setw (17) &lt;&lt;
&#34;Item&#34;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; setw (4) &lt;&lt;
&#34;Num&#34;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; setw (7) &lt;&lt;
&#34;Weight&#34;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; setw (7) &lt;&lt;
&#34;Price&#34;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; &#34;Date&#34; &lt;&lt;
endl
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; endl;
<BR>&nbsp;
<BR>&nbsp;&nbsp;&nbsp; // Now we we iterate through the vector using an iterator and
<BR>&nbsp;&nbsp;&nbsp; // produce output similar to that using Row
<BR>&nbsp;&nbsp;&nbsp; // Notice how we call the actual variables in i and not an
index
<BR>&nbsp;&nbsp;&nbsp; // offset.&nbsp; This is because the macro at the begging of the
file
<BR>&nbsp;&nbsp;&nbsp; // set up an *actual* struct of type stock which contains
the 
<BR>&nbsp;&nbsp;&nbsp; // variables item, num, weight, price, and data.
<BR>&nbsp;
<BR>&nbsp;&nbsp;&nbsp; cout.precision(3);
<BR>&nbsp;&nbsp;&nbsp; vector &lt;stock&gt;::iterator i;
<BR>&nbsp;&nbsp;&nbsp; for (i = res.begin (); i != res.end (); i++) {
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; setw (17) &lt;&lt;
i-&gt;item.c_str ()
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// unfortunally the gnu string class does not respond
to format
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// modifers so  we have to convert it to a conat char
*.
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; setw (4) &lt;&lt;
i-&gt;num
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; setw (7) &lt;&lt;
i-&gt;weight
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; setw (7) &lt;&lt;
i-&gt;price
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; i-&gt;sdate
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; endl;
<BR>&nbsp;&nbsp;&nbsp; }
<BR>&nbsp;&nbsp;&nbsp; return 0;
<BR>&nbsp;&nbsp;&nbsp; 
<BR>&nbsp; } catch (BadQuery er){ // handle any connection 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // or query errors
that may come up
<BR>&nbsp;&nbsp;&nbsp; cerr &lt;&lt; &#34;Error: &#34; &lt;&lt;
er.error &lt;&lt; endl;
<BR>&nbsp;&nbsp;&nbsp; return -1;
<BR>&nbsp;
<BR>&nbsp; } catch (BadConversion er) {
<BR>&nbsp;&nbsp;&nbsp; // we still need to cache bad conversions incase something
goes 
<BR>&nbsp;&nbsp;&nbsp; // wrong when the data is converted into stock
<BR>&nbsp;&nbsp;&nbsp; cerr &lt;&lt; &#34;Error: Tried to convert
&#92;&#34;&#34; &lt;&lt; er.data
&lt;&lt; &#34;&#92;&#34; to a &#92;&#34;&#34;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; er.type_name &lt;&lt;
&#34;&#92;&#34;.&#34; &lt;&lt;
endl;
<BR>&nbsp;&nbsp;&nbsp; return -1;
<BR>&nbsp; }
<BR>}

<P>
As you can see. SSQLS are very powerful things.

<P>

<H2><A NAME="SECTION03152000000000000000">
4.5.2 Adding Data </A>
</H2>

<P>
SSQLS can also be used to add data to a table. The file name for this
code is custom2.cc

<P>
#include &lt;iostream&gt;
<BR>#include &lt;vector&gt;
<BR>#include &lt;sqlplus.hh&gt;
<BR>#include &lt;custom.hh&gt;
<BR>#include &#34;util.hh&#34;
<BR>// util.hh/cc contains the print_stock_table function
<BR>&nbsp;
<BR>
sql_create_5(stock, 1, 5, string, item, int, num, 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double, weight, double, price, Date, sdate)
<BR>&nbsp;
<BR>
int main() {
<BR>&nbsp; try { // its in one big try block
<BR>&nbsp;
<BR>&nbsp;&nbsp;&nbsp; Connection con(use_exceptions);
<BR>&nbsp;&nbsp;&nbsp; con.connect(&#34;mysql_cpp_data&#34;);
<BR>&nbsp;&nbsp;&nbsp; Query query = con.query();
<BR>&nbsp;
<BR>&nbsp;&nbsp;&nbsp; stock row;
<BR>&nbsp;&nbsp;&nbsp; // create an empty stock object
<BR>&nbsp;&nbsp;&nbsp; 
<BR>&nbsp;&nbsp;&nbsp; /*&nbsp;&nbsp;&nbsp; row.item = &#34;Hot Dogs&#34;;
<BR>&nbsp;&nbsp;&nbsp; row.num = 100;
<BR>&nbsp;&nbsp;&nbsp; row.weight = 1.5;
<BR>&nbsp;&nbsp;&nbsp; row.price = 1.75;
<BR>&nbsp;&nbsp;&nbsp; row.sdate = &#34;1998-09-25&#34;; */
<BR>&nbsp;&nbsp;&nbsp; row.set(&#34;Hot Dogs&#34;, 100, 1.5, 1.75, &#34;1998-09-25&#34;);
<BR>&nbsp;&nbsp;&nbsp; // populate stock
<BR>&nbsp;
<BR>&nbsp;&nbsp;&nbsp; query.insert(row);
<BR>&nbsp;&nbsp;&nbsp; // form the query to insert the row
<BR>&nbsp;&nbsp;&nbsp; // the table name is the name of the struct by default
<BR>&nbsp;&nbsp;&nbsp; cout &lt;&lt; &#34;Query : &#34; &lt;&lt;
query.preview() &lt;&lt; endl;
<BR>&nbsp;&nbsp;&nbsp; // show the query about to be executed
<BR>&nbsp;&nbsp;&nbsp; query.execute();
<BR>&nbsp;&nbsp;&nbsp; // execute a query that does not return a result set
<BR>&nbsp;
<BR>&nbsp;&nbsp;&nbsp; print_stock_table(query);
<BR>&nbsp;&nbsp;&nbsp; // now print the new table;
<BR>&nbsp;&nbsp;&nbsp; 
<BR>&nbsp; } catch (BadQuery er) {
<BR>&nbsp;&nbsp;&nbsp; cerr &lt;&lt; &#34;Error: &#34; &lt;&lt;
er.error &lt;&lt; endl;
<BR>&nbsp;&nbsp;&nbsp; return -1;
<BR>&nbsp; } catch (BadConversion er) { 
<BR>&nbsp;&nbsp;&nbsp; cerr &lt;&lt; &#34;Error: Tried to convert
&#92;&#34;&#34; &lt;&lt; er.data
&lt;&lt; &#34;&#92;&#34; to a &#92;&#34;&#34;

<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; er.type_name &lt;&lt;
&#34;&#92;&#34;.&#34; &lt;&lt;
endl;
<BR>&nbsp;&nbsp;&nbsp; return -1;
<BR>&nbsp; }
<BR>}

<P>
That's all there is to it. Because this example modifies the data
you should run <TT>reset-db</TT> after running the example code.

<P>

<H2><A NAME="SECTION03153000000000000000">
4.5.3 Modifying Data </A>
</H2>

<P>
And it almost as easy to modify data with SSQLS. The file name is
custom3.cc.

<P>
#include &lt;iostream&gt;
<BR>#include &lt;vector&gt;
<BR>#include &lt;sqlplus.hh&gt;
<BR>#include &lt;custom.hh&gt;
<BR>#include &#34;util.hh&#34;
<BR>// util.hh/cc contains the print_stock_table function
<BR>&nbsp;
<BR>
sql_create_5(stock, 1, 5, string, item, int, num, 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double, weight, double, price, Date, sdate)
<BR>&nbsp;
<BR>
int main() {
<BR>&nbsp; try { // its in one big try block
<BR>&nbsp;
<BR>&nbsp;&nbsp;&nbsp; Connection con(use_exceptions);
<BR>&nbsp;&nbsp;&nbsp; con.connect(&#34;mysql_cpp_data&#34;);
<BR>&nbsp;&nbsp;&nbsp; Query query = con.query();
<BR>&nbsp;
<BR>&nbsp;&nbsp;&nbsp; query &lt;&lt; &#34;select * from stock
where item = &#92;&#34;Hotdogs' Buns&#92;&#34;
&#34;;
<BR>&nbsp;&nbsp;&nbsp; 
<BR>&nbsp;&nbsp;&nbsp; Result res = query.store();
<BR>&nbsp;&nbsp;&nbsp; if (res.empty()) 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw BadQuery(&#34;Hotdogs' Buns not found in table,
run reset-db&#34;);
<BR>&nbsp;&nbsp;&nbsp; // here we are testing if the query was successful, if not
throw a bad query
<BR>&nbsp;&nbsp;&nbsp; stock row = res[0];
<BR>&nbsp;&nbsp;&nbsp; // because there should only be one row in this query we don't
<BR>&nbsp;&nbsp;&nbsp; // need to use a vector.&nbsp; Just store the first row directly
in
<BR>&nbsp;&nbsp;&nbsp; // &#34;row&#34;.&nbsp; We can do this because one of
the constructors for
<BR>&nbsp;&nbsp;&nbsp; // stock takes a Row as an parameter.
<BR>&nbsp;
<BR>&nbsp;&nbsp;&nbsp; stock row2 = row;
<BR>&nbsp;&nbsp;&nbsp; // Now we need to create a copy so that the replace query knows
<BR>&nbsp;&nbsp;&nbsp; // what the original values are.
<BR>&nbsp;
<BR>&nbsp;&nbsp;&nbsp; row.item = &#34;Hotdog Buns&#34;; // now change item
<BR>&nbsp;
<BR>&nbsp;&nbsp;&nbsp; query.update(row2, row);
<BR>&nbsp;&nbsp;&nbsp; // form the query to replace the row
<BR>&nbsp;&nbsp;&nbsp; // the table name is the name of the struct by default
<BR>&nbsp;&nbsp;&nbsp; cout &lt;&lt; &#34;Query : &#34; &lt;&lt;
query.preview() &lt;&lt; endl;
<BR>&nbsp;&nbsp;&nbsp; // show the query about to be executed
<BR>&nbsp;&nbsp;&nbsp; query.execute();
<BR>&nbsp;&nbsp;&nbsp; // execute a query that does not return a result set
<BR>&nbsp;
<BR>&nbsp;&nbsp;&nbsp; print_stock_table(query);
<BR>&nbsp;&nbsp;&nbsp; // now print the new table;
<BR>&nbsp;&nbsp;&nbsp; 
<BR>&nbsp; } catch (BadQuery er) {
<BR>&nbsp;&nbsp;&nbsp; cerr &lt;&lt; &#34;Error: &#34; &lt;&lt;
er.error &lt;&lt; endl;
<BR>&nbsp;&nbsp;&nbsp; return -1;
<BR>&nbsp; } catch (BadConversion er) { 
<BR>&nbsp;&nbsp;&nbsp; cerr &lt;&lt; &#34;Error: Tried to convert
&#92;&#34;&#34; &lt;&lt; er.data
&lt;&lt; &#34;&#92;&#34; to a &#92;&#34;&#34;

<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; er.type_name &lt;&lt;
&#34;&#92;&#34;.&#34; &lt;&lt;
endl;
<BR>&nbsp;&nbsp;&nbsp; return -1;
<BR>&nbsp; }
<BR>}

<P>
When you run the example you will notice that in the where clause
only the <I>item</I> field is checked for. This is because SSQLS also
also less-than-comparable.

<P>
Don't forget to run <TT>reset-db</TT> after running the example.

<P>

<H2><A NAME="SECTION03154000000000000000">
4.5.4 Less-Than-Comparable</A>
</H2>

<P>
SSQLS are can also be made less-than-comparable. This means that they
can be sorted and stored in sets as demonstrated in the next example.
The file name is custom4.cc

<P>
#include &lt;iostream&gt;
<BR>#include &lt;iomanip&gt;
<BR>#include &lt;vector&gt;
<BR>#include &lt;sqlplus.hh&gt;
<BR>#include &lt;custom.hh&gt;
<BR>&nbsp;
<BR>
sql_create_5(stock, 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1, // This number is used to make a SSQLS
less-than-comparable.
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // If this number is n then if the
first n elements are the 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // same the two SSQLS are the same.&nbsp;

<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // In this case if two two stock's
&#34;item&#34; are the same then
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // the two stock are the same.
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5, // this number should generally be the
same as the number of
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // elements in the list unless you
have a good reason not to.
<BR>&nbsp;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; string,item,&nbsp; int,num,&nbsp; double,weight,&nbsp;
double,price,&nbsp; Date,sdate)
<BR>&nbsp;
<BR>
int main() {
<BR>&nbsp; try { // its in one big try block
<BR>&nbsp;
<BR>&nbsp;&nbsp;&nbsp; Connection con(use_exceptions);
<BR>&nbsp;&nbsp;&nbsp; con.connect(&#34;mysql_cpp_data&#34;);
<BR>&nbsp;&nbsp;&nbsp; Query query = con.query();
<BR>&nbsp;
<BR>&nbsp;&nbsp;&nbsp; query &lt;&lt; &#34;select * from stock&#34;;
<BR>&nbsp;&nbsp;&nbsp; 
<BR>&nbsp;&nbsp;&nbsp; set&lt;stock&gt; res;
<BR>&nbsp;&nbsp;&nbsp; query.storein(res);
<BR>&nbsp;&nbsp;&nbsp; // here we are storing the elements in a set not a vector.
<BR>&nbsp;
<BR>&nbsp;&nbsp;&nbsp; cout.setf (ios::left);
<BR>&nbsp;&nbsp;&nbsp; cout &lt;&lt; setw (17) &lt;&lt;
&#34;Item&#34;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; setw (4) &lt;&lt;
&#34;Num&#34;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; setw (7) &lt;&lt;
&#34;Weight&#34;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; setw (7) &lt;&lt;
&#34;Price&#34;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; &#34;Date&#34; &lt;&lt;
endl
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; endl;
<BR>&nbsp;
<BR>&nbsp;&nbsp;&nbsp; // Now we we iterate through the set.&nbsp; Since it is a set the
list will
<BR>&nbsp;&nbsp;&nbsp; // naturally be in order.
<BR>&nbsp;&nbsp;&nbsp; 
<BR>&nbsp;&nbsp;&nbsp; set&lt;stock&gt;::iterator i;
<BR>&nbsp;&nbsp;&nbsp; cout.precision(3);
<BR>&nbsp;&nbsp;&nbsp; for (i = res.begin (); i != res.end (); i++) {
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; setw (17) &lt;&lt;
i-&gt;item.c_str ()
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; setw (4) &lt;&lt;
i-&gt;num
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; setw (7) &lt;&lt;
i-&gt;weight
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; setw (7) &lt;&lt;
i-&gt;price
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; i-&gt;sdate
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; endl;
<BR>&nbsp;&nbsp;&nbsp; }
<BR>&nbsp;
<BR>&nbsp;&nbsp;&nbsp; i = res.find(stock(&#34;Hamburger Buns&#34;));
<BR>&nbsp;&nbsp;&nbsp; if (i != res.end())
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; &#34;Hamburger Buns found.&nbsp;
Currently &#34; &lt;&lt; i-&gt;num &lt;&lt;
&#34; in stock.&#92;n&#34;;
<BR>&nbsp;&nbsp;&nbsp; else
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; &#34;Sorry no Hamburger
Buns found in stock&#92;n&#34;;
<BR>&nbsp;
<BR>&nbsp;&nbsp;&nbsp; // Now we are using the set's find method to find out how many
<BR>&nbsp;&nbsp;&nbsp; // Hamburger Buns are in stock.
<BR>&nbsp;
<BR>&nbsp;&nbsp;&nbsp; return 0;
<BR>&nbsp;
<BR>&nbsp; } catch (BadQuery er) {
<BR>&nbsp;&nbsp;&nbsp; cerr &lt;&lt; &#34;Error: &#34; &lt;&lt;
er.error &lt;&lt; endl;
<BR>&nbsp;&nbsp;&nbsp; return -1;
<BR>&nbsp; } catch (BadConversion er) { 
<BR>&nbsp;&nbsp;&nbsp; cerr &lt;&lt; &#34;Error: Tried to convert
&#92;&#34;&#34; &lt;&lt; er.data
&lt;&lt; &#34;&#92;&#34; to a &#92;&#34;&#34;

<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; er.type_name &lt;&lt;
&#34;&#92;&#34;.&#34; &lt;&lt;
endl;
<BR>&nbsp;&nbsp;&nbsp; return -1;
<BR>&nbsp; }
<BR>}

<P>

<H1><A NAME="SECTION03160000000000000000">
4.6 Let us be usefull</A>
</H1>

<P>
Beginning with MySQl++ 1.6 we have introduced three new examples,
whose aim is to demonstrate some of the strongest features of MySQL++,
whose primary objective is not just to demonstrate power and ease
of use of MySQL++, but also to provide a solution to some of the most
frequent problems presented by MySQL users. These examples exemplify
a superiority of C++ over other existing languages. Those examples
take very few effective MySQL++ / C++ commands to produce highly efficient
code, such that each of those examples resovles some very common problems
that face MySQL users, especially beginners. 

<P>
As these examples are meant to tbe applied, and are applied by many
MySQL users, constants that can differ from one case to another have
been grouped in order to simplify editing. Also , all of this examples
contain full error checking code. This is one of the areaa where C++
exception handling, fully applied in MySQL++, truly shines. 

<P>

<H2><A NAME="SECTION03161000000000000000">
4.6.1 Loading binary file in a BLOB column</A>
</H2>

<P>
This function is solved in MySQL version 3.23 , but as of this writing
many users are still using older versions. Beside that this examples
demonstrates several features of MySQL++. This program requires one
argument, which is a full path of the binary file. 

<P>
#include &lt;sys/stat.h&gt;
<BR> #include &lt;fstream&gt;
<BR> #include &lt;mysql++&gt;
<BR>
extern int errno;
<BR>
const char&nbsp; MY_DATABASE[]=&#34;telcent&#34;;
<BR>
const char&nbsp; MY_TABLE[]=&#34;fax&#34;;
<BR>
const char&nbsp; MY_HOST[]=&#34;localhost&#34;;
<BR>
const char&nbsp; MY_USER[]=&#34;root&#34;;
<BR>
const char&nbsp; MY_PASSWORD[]=&#34;&#34;;
<BR>
const char&nbsp; MY_FIELD[]=&#34;fax&#34;; // BLOB field
<BR>
int main(int argc, char *argv[]) {
<BR> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (argc &lt; 2) {
<BR> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cerr &lt;&lt; &#34;Usage
: load_file full_file_path&#34; &lt;&lt; endl
&lt;&lt; endl;
<BR> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return -1;
<BR> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR> &nbsp; Connection con(use_exceptions);
<BR> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {
<BR> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;con.real_connect (MY_DATABASE,MY_HOST,MY_USER,MY_PASSWORD,3306,(int)0,60,NULL);
<BR> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Query query = con.query(); ostrstream
strbuf;
<BR> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ifstream In (argv[1],ios::in
| ios::binary); struct stat for_len;
<BR> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ((In.rdbuf())-&gt;is_open()) {
<BR> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (stat (argv[1],&amp;for_len)
== -1) return -1;
<BR> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned int blen
= for_len.st_size;&nbsp; if (!blen) return -1;
<BR> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp; *read_buffer
= new char[blen];&nbsp;&nbsp;&nbsp;&nbsp;In.read(read_buffer,blen); string fill(read_buffer,blen);
<BR> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;strbuf&nbsp; &lt;&lt;
&#34;INSERT INTO &#34; &lt;&lt; MY_TABLE &lt;&lt;
&#34; (&#34; &lt;&lt; MY_FIELD &lt;&lt;
&#34;) VALUES(&#92;&#34;&#34;&nbsp; &lt;&lt;
escape &lt;&lt; fill&nbsp; &lt;&lt; &#34;&#92;&#34;)&#34;;
<BR> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; query.exec(strbuf.str());
<BR> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;delete[] read_buffer;
<BR> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else 
<BR> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cerr &lt;&lt;
&#34;Your binary file &#34; &lt;&lt; argv[1]
&lt;&lt; &#34;could not be open, errno = &#34;
&lt;&lt; errno;
<BR> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 0;
<BR> &nbsp; } catch (BadQuery er) { 
<BR> &nbsp;&nbsp;&nbsp; cerr &lt;&lt; &#34;Error: &#34; &lt;&lt;
er.error &lt;&lt; &#34; &#34; &lt;&lt;
con.errnum() &lt;&lt; endl;
<BR> &nbsp;&nbsp;&nbsp; return -1;
<BR> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR> &nbsp;}
<BR>
<P>
One of the features that is displayed in this example is escape manipulator.
Although automatic quoting and escaping is introduced in version 1.6,
it is applicable to ColData classes only, as they contain info on
data type. We could also make quoting and escaping on general data
type string, but it would require to scan entire string to find out
if quoting and escaping is applicable. As this feature would slow
down code, we <SMALL>DEFINITELY NEED USER'S FEEDBACK</SMALL> on this matter.

<P>

<H2><A NAME="SECTION03162000000000000000">
4.6.1 Displaying images in HTML from BLOB column</A>
</H2>

<P>
This example is also very short one, considering a function that it
performs. Although since 3.23.3, there is a command that dumps data
from BLOB column in a binary file, this program can be used not only
by users still utilizing older versions, but by users that do not
wish to have this middle step of saving image to disk. 

<P>
#include &lt;sqlplus.hh&gt;
<BR>#define MY_DATABASE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#34;telcent&#34;
<BR> #define MY_TABLE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#34;fax&#34;
<BR> #define MY_HOST&nbsp;&nbsp;&nbsp; &#34;localhost&#34;
<BR> #define MY_USER&nbsp;&nbsp;&nbsp; &#34;root&#34;
<BR> #define MY_PASSWORD &#34;&#34;
<BR> #define MY_FIELD&nbsp;&nbsp;&nbsp; &#34;fax&#34; // BLOB field
<BR> #define MY_KEY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#34;datet&#34;&nbsp; // PRIMARY
KEY
<BR> &nbsp;int&nbsp; main (int argc, char *argv[]) {
<BR> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (argc &lt; 2) {
<BR> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cerr &lt;&lt; &#34;Usage
: cgi_image primary_key_value&#34; &lt;&lt; endl
&lt;&lt; endl;
<BR> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return -1;
<BR> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout &lt;&lt; &#34;Content-type:
image/jpeg&#34; &lt;&lt; endl;
<BR> &nbsp; Connection con(use_exceptions);
<BR> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {
<BR> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;con.real_connect (MY_DATABASE,MY_HOST,MY_USER,MY_PASSWORD,3306,(int)0,60,NULL);
<BR> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Query query = con.query();
<BR> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;query &lt;&lt; &#34;SELECT
&#34; &lt;&lt; MY_FIELD &lt;&lt; &#34;
FROM &#34; &lt;&lt; MY_TABLE &lt;&lt;
&#34; WHERE &#34; &lt;&lt; MY_KEY &lt;&lt;
&#34; = &#34; &lt;&lt; argv[1];
<BR> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ResUse res = query.use(); Row row=res.fetch_row();
long unsigned int *jj = res.fetch_lengths();
<BR> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout &lt;&lt; &#34;Content-length:
&#34; &lt;&lt; *jj &lt;&lt; endl
&lt;&lt; endl; 
<BR> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fwrite(row.raw_data(0),1,*jj,stdout);&nbsp;return
0;
<BR> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} catch (BadQuery er) { 
<BR> &nbsp;&nbsp;&nbsp; cerr &lt;&lt; &#34;Error: &#34; &lt;&lt;
er.error &lt;&lt; &#34; &#34; &lt;&lt;
con.errnum() &lt;&lt; endl;
<BR> &nbsp;&nbsp;&nbsp; return -1;
<BR> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR> }
<BR>
<P>
This example demonstrates MySQL++ handling of binary data, which was
introduced in version 1.6. Flexible usage of streams enables utilization
of this program in many applications. 

<P>

<H2><A NAME="SECTION03163000000000000000">
4.6.2 Delete or Update from Select</A>
</H2>

<P>
This feature is asked for by many users, but until it is done, this
program can be used instead. it is a small program, which also demonstrates
few MySQL++ features.

<P>
#include &lt;sqlplus.hh&gt;
<BR> #define MY_DATABASE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#34;telcent&#34;
<BR> #define MY_TABLE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#34;nazivi&#34;
<BR> #define MY_HOST&nbsp;&nbsp;&nbsp; &#34;localhost&#34;
<BR> #define MY_USER&nbsp;&nbsp;&nbsp; &#34;root&#34;
<BR> #define MY_PASSWORD &#34;&#34;
<BR> #define MY_FIELD&nbsp;&nbsp;&nbsp; &#34;naziv&#34;
<BR> #define MY_QUERY&nbsp;&nbsp;&nbsp; &#34;SELECT URL from my_table as t1,
my_table as t2 where t1.field = t2.field&#34;
<BR>
int&nbsp; main (void) {
<BR> &nbsp; Connection con(use_exceptions);
<BR> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {
<BR> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ostrstream strbuf; unsigned int i=0;

<BR> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;con.real_connect (MY_DATABASE,MY_HOST,MY_USER,MY_PASSWORD,3306,(int)0,60,NULL);
<BR> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Query query = con.query(); query
&lt;&lt; MY_QUERY; 
<BR> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ResUse res = query.use(); Row row;

<BR> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;strbuf &lt;&lt; &#34;delete
from &#34; &lt;&lt; MY_TABLE &lt;&lt;
&#34; where &#34; &lt;&lt; MY_FIELD &lt;&lt;
&#34; in (&#34;;
<BR> //&nbsp; for UPDATE just replace the above DELETE FROM with UPDATE statement
<BR> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(;row=res.fetch_row();i++) strbuf
&lt;&lt;&nbsp; row[0] &lt;&lt; &#34;,&#34;;&nbsp;if
(!i) return 0; 
<BR> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;string output(strbuf.str()); output.erase(output.size()-1,1);
output += &#34;)&#34;;
<BR> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;query.exec((const string&amp;)output);
// cout &lt;&lt; output &lt;&lt; endl;
<BR> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 0;
<BR> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} catch (BadQuery er) { 
<BR> &nbsp;&nbsp;&nbsp; cerr &lt;&lt; &#34;Error: &#34; &lt;&lt;
er.error &lt;&lt; &#34; &#34; &lt;&lt;
con.errnum() &lt;&lt; endl;
<BR> &nbsp;&nbsp;&nbsp; return -1;
<BR> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR> }
<BR>
<P>
Please do notify that in query construction command field MY_FIELD
list of values is inserted unquoted and unescaped. This way a new
feature, introduced in MySQL++ since version 1.6, is exemplified.
Namely field values will be quoted or not depending on it's type.
Users should not explicitely quote or quote + escape, as this will
result in error. This way some more burden is taken from a programmer.
Programmer may disable this feature by setting a corresponding global
veriable to false. <A HREF="5_Class.html#manip">5.1</A>This example is written to perform
DELETE. UPDATE requires some changes.

<P>
All users of this examples should beware that one more check is required
in order to run this query safely. Namely, in some extreme cases,
size of query might grow larger then max_allowed packet. Thterefore
this check should be added.

<P>

<H2><A NAME="SECTION03164000000000000000">
4.6.2 And There's More</A>
</H2>

<P>
This is only scratching the surface of what SSQLS can do for more
information see the chapter on them (<A HREF="7_Specialized.html#SSQLS">7</A>).

<P>

<H1><A NAME="SECTION03170000000000000000">
4.7 Template Queries</A>
</H1>

<P>
Another powerful feature of Mysql++ is being able to set up template
queries. The following example demonstrates how to use them. This
code is the actual code used to set up and/or reset the sample database.
It can be found under reset-db.cc.  we hope to come up with some better
examples soon.

<P>
#include &lt;iostream&gt;
<BR>#include &lt;sqlplus.hh&gt;
<BR>&nbsp;
<BR>
int main (int argc, char *argv[]) {
<BR>&nbsp; Connection connection(use_exceptions);
<BR>&nbsp; try { // the entire main block is one big try block;
<BR>&nbsp;
<BR>&nbsp;&nbsp;&nbsp; if (argc == 1) connection.connect(&#34;&#34;);
<BR>&nbsp;&nbsp;&nbsp; else if (argc == 2) connection.connect(&#34;&#34;,argv[1]);
<BR>&nbsp;&nbsp;&nbsp; else if (argc == 3) connection.connect(&#34;&#34;,argv[1],argv[2]);
<BR>&nbsp;&nbsp;&nbsp; else if (argc &lt;= 4) connection.connect(&#34;&#34;,argv[1],argv[2],argv[3]);
<BR>&nbsp;&nbsp;&nbsp; // create a new object and connect based on any (if any) arguments
<BR>&nbsp;&nbsp;&nbsp; // passed to main();
<BR>&nbsp;&nbsp;&nbsp; 
<BR>&nbsp;&nbsp;&nbsp; try {
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; connection.select_db(&#34;mysql_cpp_data&#34;);
<BR>&nbsp;&nbsp;&nbsp; } catch (BadQuery er) {
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // if it couldn't connect to the database assume that it
doesn't exist
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // and try created it.&nbsp; If that does not work exit with
an error.
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; connection.create_db(&#34;mysql_cpp_data&#34;);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; connection.select_db(&#34;mysql_cpp_data&#34;);
<BR>&nbsp;&nbsp;&nbsp; }
<BR>&nbsp;&nbsp;&nbsp; 
<BR>&nbsp;&nbsp;&nbsp; Query query = connection.query();&nbsp; // create a new query object
<BR>&nbsp;&nbsp;&nbsp; 
<BR>&nbsp;&nbsp;&nbsp; try { // ignore any errors here
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //  we hope to make this simpler soon
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; query.execute(&#34;drop table stock&#34;);
<BR>&nbsp;&nbsp;&nbsp; } catch (BadQuery er) {}
<BR>&nbsp;&nbsp;&nbsp; 
<BR>&nbsp;&nbsp;&nbsp; query &lt;&lt; &#34;create table stock&nbsp;
(item char(20) not null, num smallint,&#34;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt; &#34;weight double,
price double, sdate date)&#34;;
<BR>&nbsp;&nbsp;&nbsp; query.execute(RESET_QUERY);
<BR>&nbsp;&nbsp;&nbsp; // send the query to create the table and execute it.&nbsp; The
<BR>&nbsp;&nbsp;&nbsp; // RESET_QUERY tells the query object to reset it self after
<BR>&nbsp;&nbsp;&nbsp; // execution
<BR>&nbsp;&nbsp;&nbsp; 
<BR>&nbsp;&nbsp;&nbsp; query &lt;&lt; &#34;insert into %5:table
values (%q0, %q1, %2, %3, %q4)&#34;;
<BR>&nbsp;&nbsp;&nbsp; query.parse();
<BR>&nbsp;&nbsp;&nbsp; // set up the template query  we will use to insert the data.&nbsp;
The
<BR>&nbsp;&nbsp;&nbsp; // parse method call is important as it is what lets the query
<BR>&nbsp;&nbsp;&nbsp; // know that this is a template and not a literal string
<BR>&nbsp;&nbsp;&nbsp; 
<BR>&nbsp;&nbsp;&nbsp; query.def[&#34;table&#34;] = &#34;stock&#34;;
<BR>&nbsp;&nbsp;&nbsp; // This is setting the parameter named table to stock.
<BR>&nbsp;&nbsp;&nbsp; 
<BR>&nbsp;&nbsp;&nbsp; query.execute (&#34;Hamburger Buns&#34;, 56, 1.25,
1.1, &#34;1998-04-26&#34;);
<BR>&nbsp;&nbsp;&nbsp; query.execute (&#34;Hotdogs' Buns&#34;&nbsp;&nbsp; ,65, 1.1
, 1.1, &#34;1998-04-23&#34;);
<BR>&nbsp;&nbsp;&nbsp; query.execute (&#34;Dinner Roles&#34;&nbsp; , 75,&nbsp; .95,
.97, &#34;1998-05-25&#34;);
<BR>&nbsp;&nbsp;&nbsp; query.execute (&#34;White Bread&#34;&nbsp;&nbsp; , 87, 1.5,
1.75, &#34;1998-09-04&#34;);
<BR>&nbsp;&nbsp;&nbsp; // The last parameter &#34;table&#34; is not specified
here.&nbsp; Thus
<BR>&nbsp;&nbsp;&nbsp; // the default value for &#34;table&#34; is used
which is &#34;stock&#34;.
<BR>&nbsp;
<BR>&nbsp; } catch (BadQuery er) { // handle any errors that may come up
<BR>&nbsp;&nbsp;&nbsp; cerr &lt;&lt; &#34;Error: &#34; &lt;&lt;
er.error &lt;&lt; endl;
<BR>&nbsp;&nbsp;&nbsp; return -1;
<BR>&nbsp; }
<BR>}
<BR>&nbsp;

<P>
<HR>
<!--Navigation Panel-->
<A NAME="tex2html326"
  HREF="5_Class.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html322"
  HREF="Usage.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html316"
  HREF="Usage.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html324"
  HREF="Contents.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A>  
<BR>
<B> Next:</B> <A NAME="tex2html327"
  HREF="5_Class.html">5. Class Reference</A>
<B> Up:</B> <A NAME="tex2html323"
  HREF="Usage.html">Usage</A>
<B> Previous:</B> <A NAME="tex2html317"
  HREF="Usage.html">Usage</A>
 &nbsp <B>  <A NAME="tex2html325"
  HREF="Contents.html">Contents</A></B> 
<!--End of Navigation Panel-->
<ADDRESS>

2001-05-01
</ADDRESS>
</BODY>
</HTML>
